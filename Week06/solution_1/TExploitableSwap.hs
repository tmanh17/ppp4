{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}
{-# OPTIONS_GHC -Wno-name-shadowing #-}
{-# OPTIONS_GHC -Wno-typed-holes #-}
{-# OPTIONS_GHC -Wno-unused-matches #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

module Main where

import           Plutus.Model         (Run, Tx,
                                      TypedValidator (TypedValidator),
                                      UserSpend, ada, adaValue,
                                      defaultBabbage, mustFail,
                                      newUser, payToKey, payToScript, spend, spendScript, submitTx,
                                      toV2, userSpend, utxoAt, waitUntil, currentTimeRad, validateIn, FakeCoin (FakeCoin), testNoErrors, fakeValue, valueAt, logError, noErrors)
import           PlutusTx.Prelude     (($), Eq ((==)), (&&))
import           Prelude              (IO, (.), (<>), Integer, mconcat, Show (show), (++), Bool (True))
import qualified ExploitableSwap      as OnChain
import           Test.Tasty           (defaultMain, testGroup)
import Plutus.V2.Ledger.Api (PubKeyHash, TxOutRef, POSIXTime, TxOut (txOutValue))
import Plutus.Model.Contract (DatumMode (..))
import Control.Monad (replicateM, unless, mapM)
import Plutus.V1.Ledger.Value

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" normalSpending
      , bad  "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

waitBeforeConsumingTx :: POSIXTime
waitBeforeConsumingTx = 1000

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"

-- Set many users at once
setupUsers :: Run [PubKeyHash]
setupUsers = replicateM 3 $ newUser (ada 1000 <> fakeValue scToken 5)

type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

lockingTx :: PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx beneficiary price usp tokens =
  mconcat
    [ userSpend usp
    ,  payToScript swapScript (HashDatum (OnChain.DatumSwap beneficiary price)) tokens
    ]

consumingTx :: PubKeyHash -> PubKeyHash -> Integer -> UserSpend -> TxOutRef -> Value -> Tx
consumingTx withdrawer beneficiary price usp ref tokens =
  mconcat
    [ userSpend usp
    , payToKey beneficiary (adaValue price)
    , spendScript swapScript ref () (OnChain.DatumSwap beneficiary price)
    , payToKey withdrawer tokens
    ]


doubleConsumingTx :: PubKeyHash -> PubKeyHash -> Integer -> UserSpend -> TxOutRef -> TxOutRef -> Value -> Value -> Tx
doubleConsumingTx withdrawer beneficiary price usp ref1 ref2 val1 val2 =
  mconcat
    [ userSpend usp
    , payToKey beneficiary (adaValue price)
    , spendScript swapScript ref1 () (OnChain.DatumSwap beneficiary price)
    , payToKey withdrawer val1
    , spendScript swapScript ref2 () (OnChain.DatumSwap beneficiary price)
    , payToKey withdrawer val2
    ]

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------


normalSpending :: Run ()
normalSpending = do
  users <- setupUsers
  let [u1,u2,u3] = users
  let tokens = fakeValue scToken 1
  let price = 200
  sp1 <- spend u1 tokens
  submitTx u1 $ lockingTx u3 price sp1 tokens
  waitUntil waitBeforeConsumingTx

  utxos <- utxoAt swapScript
  let [(ref, out)] = utxos
  ct <- currentTimeRad 100
  sp2 <- spend u2 $ adaValue price
  tx <- validateIn ct $ consumingTx u2 u3 price sp2 ref (txOutValue out)
  submitTx u2 tx

  [v1, v2, v3] <- mapM valueAt [u1, u2, u3]
  let [(_,_,valToken1),(_,_,valAda1)] = flattenValue v1
  let [(_,_,valToken2),(_,_,valAda2)] = flattenValue v2
  let [(_,_,valToken3),(_,_,valAda3)] = flattenValue v3

  unless (valAda1 == 1000 && valToken1 == 4 && valAda2 == 800 && valToken2 == 6 && valAda3 == 1200 && valToken3 == 5) $ logError ("Final balances are incorrect" ++ show valAda1 ++ show valAda2 ++ show valAda3 ++ show valToken1 ++ show valToken2 ++ show valToken3)

doubleSpending :: Run Bool
doubleSpending = do
  users <- setupUsers
  let [u1,u2,u3] = users
  let tokens = fakeValue scToken 1
  let price = 200
  sp1 <- spend u1 tokens
  submitTx u1 $ lockingTx u3 price sp1 tokens
  waitUntil waitBeforeConsumingTx

  sp2 <- spend u1 tokens
  submitTx u1 $ lockingTx u3 price sp2 tokens
  waitUntil waitBeforeConsumingTx

  utxos <- utxoAt swapScript
  let [(ref1, out1), (ref2,out2)] = utxos
  ct <- currentTimeRad 100
  sp2 <- spend u2 $ adaValue price
  tx <- validateIn ct $ doubleConsumingTx u2 u3 price sp2 ref1 ref2 (txOutValue out1) (txOutValue out2)
  submitTx u2 tx

  [v1, v2, v3] <- mapM valueAt [u1, u2, u3]
  -- let [(_,_,valToken1),(_,_,valAda1)] = flattenValue v1
  -- let [(_,_,valToken2),(_,_,valAda2)] = flattenValue v2
  -- let [(_,_,valToken3),(_,_,valAda3)] = flattenValue v3
  noErrors
  --unless (valAda1 == 1000 && valToken1 == 4 && valAda2 == 800 && valToken2 == 6 && valAda3 == 1200 && valToken3 == 5) $ logError ("Final balances are incorrect" ++ show valAda1 ++ show valAda2 ++ show valAda3 ++ show valToken1 ++ show valToken2 ++ show valToken3)


